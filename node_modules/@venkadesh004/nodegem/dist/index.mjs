var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/functions.ts
import { GoogleGenerativeAI } from "@google/generative-ai";
import fs from "fs";
import path from "path";
import { google } from "googleapis";
import { authenticate } from "@google-cloud/local-auth";
import { v2 } from "@google-cloud/translate";
import axios from "axios";
var nodemailer = __require("nodemailer");
var NodeGem = class {
  API_KEY;
  modelName;
  currentModel;
  maxOutputTokens = 100;
  stopSequence = ["red"];
  temperature = 0.9;
  topP = 0.1;
  topK = 16;
  safetySettings;
  jwtClient;
  authConnect;
  gmail;
  translate = new v2.Translate();
  bloggerAPIKey;
  constructor(API_KEY, modelName) {
    this.API_KEY = API_KEY;
    this.modelName = modelName;
    this.currentModel = new GoogleGenerativeAI(this.API_KEY).getGenerativeModel({ model: this.modelName });
  }
  async generateContent(prompt, stream) {
    if (this.modelName !== "gemini-pro") {
      return "Use Gemini pro";
    }
    if (stream) {
      const result2 = await this.currentModel.generateContentStream(prompt);
      const response2 = await result2.response;
      return response2.text();
    }
    const result = await this.currentModel.generateContent(prompt);
    const response = await result.response;
    return response.text();
  }
  switchModel(modelName) {
    this.modelName = modelName;
    this.currentModel = new GoogleGenerativeAI(this.API_KEY).getGenerativeModel({ model: this.modelName });
  }
  fileToGenerativePart(path2, mimeType) {
    return {
      inlineData: {
        data: Buffer.from(fs.readFileSync(path2)).toString("base64"),
        mimeType
      }
    };
  }
  async useTextAndImage(imageParts, stream, prompt) {
    if (this.modelName === "gemini-pro") {
      return "use Gemini pro Vision";
    }
    var newImageParts = [];
    imageParts.forEach((element) => {
      newImageParts.push(this.fileToGenerativePart(element[0], element[1]));
    });
    if (stream) {
      const result2 = await this.currentModel.generateContentStream([prompt, ...newImageParts]);
      const response2 = await result2.response;
      return response2.text();
    }
    const result = await this.currentModel.generateContent([prompt, ...newImageParts]);
    const response = await result.response;
    return response.text();
  }
  changeConfig({ maxOutputTokens, temperature, topP, topK, stopSequence }) {
    this.maxOutputTokens = maxOutputTokens;
    this.temperature = temperature;
    this.topK = topK;
    this.topP = topP;
    this.stopSequence = stopSequence;
    const generationConfig = {
      maxOuptutTokens: this.maxOutputTokens,
      stopSequences: this.stopSequence,
      temperature: this.temperature,
      topK: this.topK,
      topP: this.topP
    };
    this.currentModel = new GoogleGenerativeAI(this.API_KEY).getGenerativeModel({ model: this.modelName, generationConfig });
  }
  changeSafetySettings(input) {
    this.safetySettings = input;
    this.currentModel = new GoogleGenerativeAI(this.API_KEY).getGenerativeModel({ model: this.modelName, safetySettings: this.safetySettings });
  }
  async loadSavedCredentialsIfExist(token_path) {
    try {
      const content = (await fs.promises.readFile(token_path)).toLocaleString();
      const credentials = JSON.parse(content);
      return google.auth.fromJSON(credentials);
    } catch (err) {
      return null;
    }
  }
  async connectServiceAccount(clientKey, keyFile, privateKey, scopes) {
    this.jwtClient = new google.auth.JWT(
      clientKey,
      keyFile,
      privateKey,
      scopes
    );
    await this.jwtClient.authorize();
  }
  async saveCredentials(client, credentials_path, token_path) {
    const content = (await fs.promises.readFile(credentials_path)).toLocaleString();
    const keys = JSON.parse(content);
    const key = keys.installed || keys.web;
    const payload = JSON.stringify({
      type: "authorized_user",
      client_id: key.client_id,
      client_secret: key.client_secret,
      refresh_token: client.credentials.refresh_token
    });
    await fs.promises.writeFile(token_path, payload);
  }
  async connectAuthClient(token_path, credentials_path, scopes) {
    this.authConnect = await this.loadSavedCredentialsIfExist(token_path);
    if (this.authConnect) {
      this.gmail = google.gmail({ version: "v1", auth: this.authConnect });
      return;
    }
    this.authConnect = await authenticate({
      scopes,
      keyfilePath: credentials_path
    });
    if (this.authConnect.credentials) {
      this.gmail = google.gmail({ version: "v1", auth: this.authConnect });
      await this.saveCredentials(this.authConnect, credentials_path, token_path);
    }
  }
  async listFiles(pageSize) {
    const drive = google.drive({ version: "v3", auth: this.jwtClient });
    const res = await drive.files.list({
      pageSize,
      fields: "nextPageToken, files(id, name)"
    });
    const files = res.data.files;
    if (files?.length === 0) {
      console.log("No files Found!");
      return process.exit();
    }
    var list = [];
    files?.map((file) => {
      list.push([file.name, file.id]);
    });
    return list;
  }
  async uploadFile(fileName) {
    const drive = google.drive({ version: "v3", auth: this.jwtClient });
    if (fileName) {
      const file = await drive.files.create({
        media: {
          body: fs.createReadStream(fileName)
        },
        fields: "id",
        requestBody: {
          name: path.basename(fileName)
        }
      });
      return file.data.id;
    } else
      return "Please specify a file Name";
  }
  async updateFile(fileName, fileId) {
    const drive = google.drive({ version: "v3", auth: this.jwtClient });
    if (fileName && fileId) {
      const file = await drive.files.update({
        media: {
          body: fs.createReadStream(fileName)
        },
        fileId
      });
      return file.data.id;
    } else
      return "Please specify file name/file id";
  }
  async downloadFile(fileName, fileId, listenerFunction) {
    const drive = google.drive({ version: "v3", auth: this.jwtClient });
    if (fileName && fileId) {
      let dest = fs.createWriteStream(fileName);
      drive.files.get(
        { fileId, alt: "media" },
        { responseType: "stream" },
        (err, response) => {
          if (err) {
            console.log(err);
            return;
          }
          response?.data.on("end", listenerFunction).on("error", (err2) => {
            console.log(err2);
            return process.exit();
          }).pipe(dest);
        }
      );
    } else
      return "Please specify file name/file id";
  }
  async driveAndPrompt(prompt, fileName, fileId) {
    if (this.modelName === "google-pro") {
      return "Use Gemini Pro Vision";
    }
    const drive = google.drive({ version: "v3", auth: this.jwtClient });
    if (fileName && fileId) {
      return new Promise(
        (resolve, reject) => {
          const chunks = [];
          drive.files.get(
            { fileId, alt: "media" },
            { responseType: "stream" },
            (err, response) => {
              if (err) {
                console.log(err);
                return process.exit();
              }
              response?.data.on("data", (chunk) => chunks.push(Buffer.from(chunk))).on("error", () => {
                console.log(err);
                reject(process.exit());
              }).on("end", async () => {
                let imagePart = [{
                  inlineData: {
                    data: Buffer.concat(chunks).toString("base64"),
                    mimeType: "image/png"
                  }
                }];
                const result = await this.currentModel.generateContent([prompt, ...imagePart]);
                resolve(result.response.text());
              });
            }
          );
        }
      );
    } else
      return "Please specify file name/file id";
  }
  async returnImageBuffer(fileName, fileId) {
    const drive = google.drive({ version: "v3", auth: this.jwtClient });
    if (fileName && fileId) {
      return new Promise((resolve, reject) => {
        const chunks = [];
        drive.files.get(
          { fileId, alt: "media" },
          { responseType: "stream" },
          (err, response) => {
            if (err) {
              reject(err);
            }
            response?.data.on("data", (chunk) => chunks.push(Buffer.from(chunk))).on("error", () => {
              resolve("Error");
            }).on("end", () => {
              resolve(Buffer.concat(chunks).toString("base64"));
            });
          }
        );
      });
    } else
      return "Please specify file name/file id";
  }
  async returnSnippet(userId, maxResult) {
    if (this.gmail === void 0) {
      console.log("Mail is Not defined");
      return process.exit();
    }
    const mails = (await this.gmail.users.messages.list({ userId, maxResults: maxResult }))?.data?.messages;
    if (mails !== void 0) {
      var listSnippets = [];
      for (const message of mails) {
        const msg = this.gmail.users.messages.get({
          userId,
          id: message.id
        });
        listSnippets.push((await msg).data.snippet);
      }
      return listSnippets;
    } else {
      return [];
    }
  }
  async promptSnippet(userId, snippetID, prompt) {
    if (this.gmail === void 0) {
      console.log("Mail is Not defined");
      return process.exit();
    }
    if (this.modelName === "gemini-pro-vision") {
      console.log("Use Gemini Pro");
      return process.exit();
    }
    return new Promise((resolve, reject) => {
      const msg = this.gmail.users.messages.get({
        userId,
        id: snippetID
      }).then(async (result) => {
        const output = this.currentModel.generateContent([prompt, result.data.snippet]);
        resolve((await output).response.text());
      }).catch((err) => {
        console.log(err);
        reject(err);
      });
    });
  }
  async sendMail(from, to, subject, text, html, name, prompt) {
    if (this.modelName === "gemini-pro-vision") {
      return "Use gemini-pro";
    }
    const oAuth2Client = new google.auth.OAuth2(
      this.authConnect._clientId,
      this.authConnect._clientSecret,
      this.authConnect.redirectUri
    );
    oAuth2Client.setCredentials({ refresh_token: this.authConnect._refreshToken });
    try {
      const accessToken = await oAuth2Client.getAccessToken();
      const transport = nodemailer.createTransport({
        service: "gmail",
        auth: {
          type: "OAuth2",
          user: "yours authorised email address",
          clientId: this.authConnect._clientId,
          clientSecret: this.authConnect._clientSecret,
          refreshToken: this.authConnect._refreshToken,
          accessToken
        }
      });
      const result = await this.currentModel.generateContent([prompt, text]);
      const data = result.response.text();
      const mailOptions = {
        from: `${name} <${from}>`,
        to: `${to}`,
        subject: `${subject}`,
        text: `${data}`,
        html: `${html}`
      };
      console.log(mailOptions);
      const output = await transport.sendMail(mailOptions);
      return output;
    } catch (error) {
      return error;
    }
  }
  async translateText(text, targetLang) {
    let [translations] = await this.translate.translate(text, targetLang);
    return translations;
  }
  async getBlogData(API_KEY, bloggerID) {
    this.bloggerAPIKey = API_KEY;
    const result = await axios.get(`https://www.googleapis.com/blogger/v3/blogs/${bloggerID}?key=${API_KEY}`);
    return result.data;
  }
  async generateBlogContent(prompt) {
    const result = await this.currentModel.generateContent(prompt);
    return result.response.text();
  }
  async getBlogContent(API_KEY, bloggerID, doPrompt, prompt) {
    this.bloggerAPIKey = API_KEY;
    const result = await axios.get(`https://www.googleapis.com/blogger/v3/blogs/${bloggerID}/posts?key=${API_KEY}`);
    if (!doPrompt) {
      return result.data;
    }
    var list = result.data.items.map((element) => element.content);
    const output = await this.currentModel.generateContent([prompt, ...list]);
    return output.response.text();
  }
};
export {
  NodeGem
};
